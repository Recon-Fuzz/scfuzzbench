name: Benchmark Run

on:
  workflow_dispatch:
    inputs:
      target_repo_url:
        description: "Target repository URL."
        required: true
      target_commit:
        description: "Target repository commit hash."
        required: true
      benchmark_type:
        description: "Benchmark type."
        required: true
        type: choice
        options:
          - property
          - optimization
        default: property
      instance_type:
        description: "EC2 instance type."
        required: true
        default: c6a.8xlarge
      instances_per_fuzzer:
        description: "Number of instances per fuzzer."
        required: true
        type: number
        default: 10
      timeout_hours:
        description: "Timeout per fuzzer run (hours)."
        required: true
        type: number
        default: 24
      fuzzers_json:
        description: "JSON list of fuzzer keys to run (optional)."
        required: false
        default: '["echidna","medusa","foundry"]'
      foundry_version:
        description: "Override Foundry version (optional)."
        required: false
        default: ""
      foundry_git_repo:
        description: "Optional Foundry git repo (build from source)."
        required: false
        default: ""
      foundry_git_ref:
        description: "Optional Foundry git ref (branch/tag/commit)."
        required: false
        default: ""
      echidna_version:
        description: "Override Echidna version (optional)."
        required: false
        default: ""
      medusa_version:
        description: "Override Medusa version (optional)."
        required: false
        default: ""
      bitwuzla_version:
        description: "Override Bitwuzla version (optional)."
        required: false
        default: ""
      git_token_ssm_parameter_name:
        description: "SSM parameter name for Git token (optional)."
        required: false
        default: ""
      properties_path:
        description: "Repo-relative properties path for benchmark mode switching (optional)."
        required: false
        default: ""
      fuzzer_env_json:
        description: "JSON map of extra fuzzer env vars (optional)."
        required: false
        default: ""
  workflow_call:
    inputs:
      target_repo_url:
        description: "Target repository URL."
        required: true
        type: string
      target_commit:
        description: "Target repository commit hash."
        required: true
        type: string
      benchmark_type:
        description: "Benchmark type."
        required: false
        type: string
        default: property
      instance_type:
        description: "EC2 instance type."
        required: false
        type: string
        default: c6a.8xlarge
      instances_per_fuzzer:
        description: "Number of instances per fuzzer."
        required: false
        type: number
        default: 10
      timeout_hours:
        description: "Timeout per fuzzer run (hours)."
        required: false
        type: number
        default: 24
      fuzzers_json:
        description: "JSON list of fuzzer keys to run (optional)."
        required: false
        type: string
        default: '["echidna","medusa","foundry"]'
      foundry_version:
        description: "Override Foundry version (optional)."
        required: false
        type: string
        default: ""
      foundry_git_repo:
        description: "Optional Foundry git repo (build from source)."
        required: false
        type: string
        default: ""
      foundry_git_ref:
        description: "Optional Foundry git ref (branch/tag/commit)."
        required: false
        type: string
        default: ""
      echidna_version:
        description: "Override Echidna version (optional)."
        required: false
        type: string
        default: ""
      medusa_version:
        description: "Override Medusa version (optional)."
        required: false
        type: string
        default: ""
      bitwuzla_version:
        description: "Override Bitwuzla version (optional)."
        required: false
        type: string
        default: ""
      git_token_ssm_parameter_name:
        description: "SSM parameter name for Git token (optional)."
        required: false
        type: string
        default: ""
      properties_path:
        description: "Repo-relative properties path for benchmark mode switching (optional)."
        required: false
        type: string
        default: ""
      fuzzer_env_json:
        description: "JSON map of extra fuzzer env vars (optional)."
        required: false
        type: string
        default: ""
    secrets:
      AWS_ACCESS_KEY_ID:
        required: true
      AWS_SECRET_ACCESS_KEY:
        required: true
      SCFUZZBENCH_BUCKET:
        required: true
      TF_BACKEND_CONFIG:
        required: true
      AWS_REGION:
        required: false
    outputs:
      run_id:
        description: "Run ID (Unix timestamp)."
        value: ${{ jobs.benchmark-run.outputs.run_id }}
      benchmark_uuid:
        description: "Benchmark UUID (derived from manifest)."
        value: ${{ jobs.benchmark-run.outputs.benchmark_uuid }}

permissions:
  contents: read

concurrency:
  group: benchmark-run-global-dispatch
  cancel-in-progress: false

jobs:
  benchmark-run:
    runs-on: ubuntu-latest
    outputs:
      run_id: ${{ steps.tf_outputs.outputs.run_id }}
      benchmark_uuid: ${{ steps.tf_outputs.outputs.benchmark_uuid }}
    env:
      AWS_REGION: ${{ secrets.AWS_REGION != '' && secrets.AWS_REGION || 'us-east-1' }}
      SCFUZZBENCH_BUCKET: ${{ secrets.SCFUZZBENCH_BUCKET }}
      SCFUZZBENCH_LOCK_TABLE: scfuzzbench-control-locks
      SCFUZZBENCH_LOCK_NAME: benchmark-global-lock
    steps:
      - name: Checkout (tarball)
        timeout-minutes: 5
        env:
          REPO: ${{ github.repository }}
          SHA: ${{ github.sha }}
        run: |
          set -euo pipefail
          url="https://codeload.github.com/${REPO}/tar.gz/${SHA}"
          curl -fsSL "${url}" -o repo.tar.gz
          topdir="$(tar -tzf repo.tar.gz | sed -n '1p' | cut -d/ -f1)"
          tar -xzf repo.tar.gz
          shopt -s dotglob
          mv "${topdir}"/* .
          rm -rf "${topdir}" repo.tar.gz

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.5.7

      - name: Ensure AWS credentials are configured
        run: |
          if [ -z "${{ secrets.AWS_ACCESS_KEY_ID }}" ] || [ -z "${{ secrets.AWS_SECRET_ACCESS_KEY }}" ]; then
            echo "Set AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY secrets." >&2
            exit 1
          fi
          if [ -z "${AWS_REGION}" ]; then
            echo "Set AWS_REGION secret." >&2
            exit 1
          fi
          if [ -z "${SCFUZZBENCH_BUCKET}" ]; then
            echo "Set SCFUZZBENCH_BUCKET secret." >&2
            exit 1
          fi

      - name: Configure AWS credentials (keys)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Write backend config from secret
        env:
          TF_BACKEND_CONFIG: ${{ secrets.TF_BACKEND_CONFIG }}
        run: |
          set -euo pipefail
          if [ -n "${TF_BACKEND_CONFIG}" ]; then
            printf '%s' "${TF_BACKEND_CONFIG}" > infrastructure/backend.hcl
          fi

      - name: Ensure backend config exists
        run: |
          if [ ! -f infrastructure/backend.hcl ]; then
            echo "Missing infrastructure/backend.hcl. Create it or set TF_BACKEND_CONFIG secret." >&2
            exit 1
          fi

      - name: Terraform init (remote backend)
        run: make terraform-init-backend BACKEND_CONFIG=backend.hcl

      - name: Validate inputs
        env:
          TARGET_REPO_URL: ${{ inputs.target_repo_url }}
          TARGET_COMMIT: ${{ inputs.target_commit }}
          BENCHMARK_TYPE: ${{ inputs.benchmark_type }}
          INSTANCE_TYPE: ${{ inputs.instance_type }}
          INSTANCES_PER_FUZZER: ${{ inputs.instances_per_fuzzer }}
          TIMEOUT_HOURS: ${{ inputs.timeout_hours }}
          FUZZERS_JSON: ${{ inputs.fuzzers_json }}
          FOUNDRY_VERSION: ${{ inputs.foundry_version }}
          FOUNDRY_GIT_REPO: ${{ inputs.foundry_git_repo }}
          FOUNDRY_GIT_REF: ${{ inputs.foundry_git_ref }}
          ECHIDNA_VERSION: ${{ inputs.echidna_version }}
          MEDUSA_VERSION: ${{ inputs.medusa_version }}
          BITWUZLA_VERSION: ${{ inputs.bitwuzla_version }}
          GIT_TOKEN_SSM_PARAMETER_NAME: ${{ inputs.git_token_ssm_parameter_name }}
          PROPERTIES_PATH: ${{ inputs.properties_path }}
          FUZZER_ENV_JSON: ${{ inputs.fuzzer_env_json }}
        run: |
          set -euo pipefail

          fail() {
            echo "Invalid input: $1" >&2
            exit 1
          }

          is_single_line() {
            [[ "$1" != *$'\n'* && "$1" != *$'\r'* ]]
          }

          # These values are interpolated into Terraform args and later into user-data.
          # Keep them conservative to avoid shell-quoting surprises.
          has_forbidden_chars() {
            local s="$1"
            [[ "$s" == *\"* || "$s" == *"$"* || "$s" == *$'\x60'* || "$s" == *\\* ]]
          }

          require_safe() {
            local name="$1"
            local value="$2"
            if ! is_single_line "$value"; then
              fail "${name} must be a single line"
            fi
            if has_forbidden_chars "$value"; then
              fail "${name} contains a forbidden character (double quote, backslash, dollar sign, or backtick)"
            fi
          }

          require_safe "target_repo_url" "${TARGET_REPO_URL}"
          require_safe "target_commit" "${TARGET_COMMIT}"
          require_safe "benchmark_type" "${BENCHMARK_TYPE}"
          require_safe "instance_type" "${INSTANCE_TYPE}"

          if [[ -n "${FOUNDRY_VERSION}" ]]; then
            require_safe "foundry_version" "${FOUNDRY_VERSION}"
            if [[ ! "${FOUNDRY_VERSION}" =~ ^[A-Za-z0-9._+-]+$ ]]; then
              fail "foundry_version must not contain spaces"
            fi
          fi

          if [[ -n "${FOUNDRY_GIT_REPO}" ]]; then
            require_safe "foundry_git_repo" "${FOUNDRY_GIT_REPO}"
            if [[ ! "${FOUNDRY_GIT_REPO}" =~ ^https://github\.com/[A-Za-z0-9_.-]+/[A-Za-z0-9_.-]+(\.git)?/?$ ]]; then
              fail "foundry_git_repo must be https://github.com/<org>/<repo>"
            fi
          fi

          if [[ -n "${FOUNDRY_GIT_REF}" ]]; then
            require_safe "foundry_git_ref" "${FOUNDRY_GIT_REF}"
            if [[ ! "${FOUNDRY_GIT_REF}" =~ ^[A-Za-z0-9._/-]+$ ]]; then
              fail "foundry_git_ref must not contain spaces"
            fi
          fi

          if [[ -n "${ECHIDNA_VERSION}" ]]; then
            require_safe "echidna_version" "${ECHIDNA_VERSION}"
          fi
          if [[ -n "${MEDUSA_VERSION}" ]]; then
            require_safe "medusa_version" "${MEDUSA_VERSION}"
          fi
          if [[ -n "${BITWUZLA_VERSION}" ]]; then
            require_safe "bitwuzla_version" "${BITWUZLA_VERSION}"
          fi

          if [[ ! "${TARGET_REPO_URL}" =~ ^https://github\.com/[A-Za-z0-9_.-]+/[A-Za-z0-9_.-]+(\.git)?/?$ ]]; then
            fail "target_repo_url must be https://github.com/<org>/<repo>"
          fi

          if [[ ! "${TARGET_COMMIT}" =~ ^[A-Za-z0-9][A-Za-z0-9._/-]{0,199}$ ]]; then
            fail "target_commit must be a commit SHA, tag, or branch (no spaces)"
          fi

          case "${BENCHMARK_TYPE}" in
            property|optimization) ;;
            *) fail "benchmark_type must be property or optimization" ;;
          esac

          if [[ ! "${INSTANCE_TYPE}" =~ ^[a-z0-9]+\.[a-z0-9]+$ ]]; then
            fail "instance_type must look like c6a.4xlarge"
          fi

          if [[ ! "${INSTANCES_PER_FUZZER}" =~ ^[0-9]+$ ]] || (( INSTANCES_PER_FUZZER < 1 )) || (( INSTANCES_PER_FUZZER > 20 )); then
            fail "instances_per_fuzzer must be an integer in [1, 20]"
          fi

          if [[ ! "${TIMEOUT_HOURS}" =~ ^[0-9]+(\.[0-9]+)?$ ]]; then
            fail "timeout_hours must be a number"
          fi
          python3 - <<'PY'
          import os
          hours = float(os.environ["TIMEOUT_HOURS"])
          if hours < 0.25 or hours > 72:
              raise SystemExit("timeout_hours must be in [0.25, 72]")
          PY

          python3 - <<'PY'
          import json
          import os
          import re

          raw = os.environ.get("FUZZERS_JSON", "").strip()
          if not raw:
              raw = '["echidna","medusa","foundry"]'
          try:
              obj = json.loads(raw)
          except Exception as e:
              raise SystemExit(f"fuzzers_json must be valid JSON: {e}")
          if not isinstance(obj, list):
              raise SystemExit("fuzzers_json must be a JSON list")
          if len(obj) < 1:
              raise SystemExit("fuzzers_json must include at least one fuzzer key")
          if len(obj) > 20:
              raise SystemExit("fuzzers_json has too many entries (max 20)")
          key_re = re.compile(r"^[a-z0-9][a-z0-9-]{0,63}$")
          for v in obj:
              if not isinstance(v, str) or not key_re.match(v):
                  raise SystemExit(f"Invalid fuzzer key: {v!r}")
          PY

          if [[ -n "${GIT_TOKEN_SSM_PARAMETER_NAME}" ]]; then
            require_safe "git_token_ssm_parameter_name" "${GIT_TOKEN_SSM_PARAMETER_NAME}"
            if [[ ! "${GIT_TOKEN_SSM_PARAMETER_NAME}" =~ ^/scfuzzbench/[A-Za-z0-9_./-]+$ ]]; then
              fail "git_token_ssm_parameter_name must start with /scfuzzbench/"
            fi
          fi

          if [[ -n "${PROPERTIES_PATH}" ]]; then
            require_safe "properties_path" "${PROPERTIES_PATH}"
            if [[ "${PROPERTIES_PATH}" == /* || "${PROPERTIES_PATH}" == *".."* ]]; then
              fail "properties_path must be repo-relative and must not contain '..'"
            fi
            if [[ ! "${PROPERTIES_PATH}" =~ ^[A-Za-z0-9_./-]+$ ]]; then
              fail "properties_path must not contain spaces"
            fi
          fi

          if [[ -n "${FUZZER_ENV_JSON}" ]]; then
            python3 - <<'PY'
          import json
          import os
          import re
          raw = os.environ["FUZZER_ENV_JSON"]
          try:
              obj = json.loads(raw)
          except Exception as e:
              raise SystemExit(f"Invalid fuzzer_env_json: {e}")
          if not isinstance(obj, dict):
              raise SystemExit("fuzzer_env_json must be a JSON object")
          if len(obj) > 64:
              raise SystemExit("fuzzer_env_json has too many keys (max 64)")
          key_re = re.compile(r"^[A-Z][A-Z0-9_]{0,63}$")
          forbidden = re.compile(r'[\r\n"`$\\\\]')
          for k, v in obj.items():
              if not isinstance(k, str) or not key_re.match(k):
                  raise SystemExit(f"Invalid env key: {k}")
              if not isinstance(v, str):
                  raise SystemExit(f"Env value for {k} must be a string")
              if len(v) > 2000:
                  raise SystemExit(f"Env value for {k} too long (max 2000 chars)")
              if forbidden.search(v):
                  raise SystemExit(f"Env value for {k} contains a forbidden character")
          PY
          fi

      - name: Plan shards and discover effective parallelism
        id: shard_plan
        env:
          INSTANCE_TYPE: ${{ inputs.instance_type }}
          INSTANCES_PER_FUZZER: ${{ inputs.instances_per_fuzzer }}
          FUZZERS_JSON: ${{ inputs.fuzzers_json }}
        run: |
          set -euo pipefail
          run_id="$(date +%s)"
          fuzzers="${FUZZERS_JSON:-}"
          if [[ -z "${fuzzers}" ]]; then
            fuzzers='["echidna","medusa","foundry"]'
          fi
          fuzzer_count="$(python3 - <<'PY'
          import json
          import os
          obj = json.loads(os.environ["FUZZERS_JSON"] or '["echidna","medusa","foundry"]')
          print(len(obj))
          PY
          )"
          requested_shards="$((INSTANCES_PER_FUZZER * fuzzer_count))"

          instance_vcpus="$(aws ec2 describe-instance-types --instance-types "${INSTANCE_TYPE}" --query 'InstanceTypes[0].VCpuInfo.DefaultVCpus' --output text 2>/dev/null || true)"
          quota_vcpus="$(aws service-quotas get-service-quota --service-code ec2 --quota-code L-1216C47A --query 'Quota.Value' --output text 2>/dev/null || true)"
          effective_parallel="$(REQUESTED_SHARDS="${requested_shards}" INSTANCE_VCPUS="${instance_vcpus}" QUOTA_VCPUS="${quota_vcpus}" python3 - <<'PY'
          import math
          import os

          requested = int(os.environ["REQUESTED_SHARDS"])
          instance_vcpus = os.environ.get("INSTANCE_VCPUS", "").strip()
          quota_vcpus = os.environ.get("QUOTA_VCPUS", "").strip()

          effective = requested
          try:
              iv = int(float(instance_vcpus))
              qv = float(quota_vcpus)
              if iv > 0 and qv > 0:
                  slots = int(math.floor(qv / iv))
                  if slots < 1:
                      slots = 1
                  effective = min(requested, slots)
          except Exception:
              pass

          if effective < 1:
              effective = 1
          print(effective)
          PY
          )"

          {
            echo "run_id=${run_id}"
            echo "fuzzers_json=${fuzzers}"
            echo "requested_shards=${requested_shards}"
            echo "effective_parallel=${effective_parallel}"
            echo "instance_vcpus=${instance_vcpus}"
            echo "quota_vcpus=${quota_vcpus}"
          } >> "${GITHUB_OUTPUT}"

      - name: Ensure global lock table exists
        run: |
          set -euo pipefail
          if ! aws dynamodb describe-table --table-name "${SCFUZZBENCH_LOCK_TABLE}" >/dev/null 2>&1; then
            aws dynamodb create-table \
              --table-name "${SCFUZZBENCH_LOCK_TABLE}" \
              --attribute-definitions AttributeName=lock_name,AttributeType=S \
              --key-schema AttributeName=lock_name,KeyType=HASH \
              --billing-mode PAY_PER_REQUEST >/dev/null
            aws dynamodb wait table-exists --table-name "${SCFUZZBENCH_LOCK_TABLE}"
            aws dynamodb update-time-to-live \
              --table-name "${SCFUZZBENCH_LOCK_TABLE}" \
              --time-to-live-specification Enabled=true,AttributeName=expires_at >/dev/null || true
          fi

      - name: Acquire global run lock
        id: lock
        env:
          RUN_ID: ${{ steps.shard_plan.outputs.run_id }}
          TIMEOUT_HOURS: ${{ inputs.timeout_hours }}
        run: |
          set -euo pipefail
          now_epoch="$(date +%s)"
          expires_epoch="$(python3 - <<'PY'
          import os
          import time
          now = int(time.time())
          timeout_hours = float(os.environ["TIMEOUT_HOURS"])
          # timeout + 2h grace for teardown and queue drain finalization
          print(now + int(timeout_hours * 3600) + 7200)
          PY
          )"
          acquired_at="$(date -u +%Y-%m-%dT%H:%M:%SZ)"

          item="$(jq -cn \
            --arg lock_name "${SCFUZZBENCH_LOCK_NAME}" \
            --arg owner_run_id "${RUN_ID}" \
            --arg acquired_at "${acquired_at}" \
            --arg expires_at "${expires_epoch}" \
            --arg workflow_run_id "${GITHUB_RUN_ID}" \
            '{lock_name:{S:$lock_name},owner_run_id:{S:$owner_run_id},acquired_at:{S:$acquired_at},expires_at:{N:$expires_at},workflow_run_id:{S:$workflow_run_id}}')"
          cond_vals="$(jq -cn --arg now "${now_epoch}" '{":now":{N:$now}}')"

          aws dynamodb put-item \
            --table-name "${SCFUZZBENCH_LOCK_TABLE}" \
            --item "${item}" \
            --condition-expression "attribute_not_exists(lock_name) OR expires_at < :now" \
            --expression-attribute-values "${cond_vals}" >/dev/null

          echo "lock_acquired=true" >> "${GITHUB_OUTPUT}"

      - name: Terraform apply
        id: apply
        env:
          TARGET_REPO_URL: ${{ inputs.target_repo_url }}
          TARGET_COMMIT: ${{ inputs.target_commit }}
          BENCHMARK_TYPE: ${{ inputs.benchmark_type }}
          INSTANCE_TYPE: ${{ inputs.instance_type }}
          INSTANCES_PER_FUZZER: ${{ inputs.instances_per_fuzzer }}
          TIMEOUT_HOURS: ${{ inputs.timeout_hours }}
          FUZZERS_JSON: ${{ steps.shard_plan.outputs.fuzzers_json }}
          MAX_PARALLEL_EFFECTIVE: ${{ steps.shard_plan.outputs.effective_parallel }}
          RUN_ID: ${{ steps.shard_plan.outputs.run_id }}
          FOUNDRY_VERSION: ${{ inputs.foundry_version }}
          FOUNDRY_GIT_REPO: ${{ inputs.foundry_git_repo }}
          FOUNDRY_GIT_REF: ${{ inputs.foundry_git_ref }}
          ECHIDNA_VERSION: ${{ inputs.echidna_version }}
          MEDUSA_VERSION: ${{ inputs.medusa_version }}
          BITWUZLA_VERSION: ${{ inputs.bitwuzla_version }}
          GIT_TOKEN_SSM_PARAMETER_NAME: ${{ inputs.git_token_ssm_parameter_name }}
          FUZZER_ENV_JSON: ${{ inputs.fuzzer_env_json }}
          PROPERTIES_PATH: ${{ inputs.properties_path }}
        run: |
          set -euo pipefail
          fuzzers="${FUZZERS_JSON:-}"
          if [[ -z "${fuzzers}" ]]; then
            fuzzers='["echidna","medusa","foundry"]'
          fi
          tf_args=(
            -var "aws_region=${AWS_REGION}"
            -var "existing_bucket_name=${SCFUZZBENCH_BUCKET}"
            -var "target_repo_url=${TARGET_REPO_URL}"
            -var "target_commit=${TARGET_COMMIT}"
            -var "benchmark_type=${BENCHMARK_TYPE}"
            -var "instance_type=${INSTANCE_TYPE}"
            -var "instances_per_fuzzer=${INSTANCES_PER_FUZZER}"
            -var "max_parallel_instances=${MAX_PARALLEL_EFFECTIVE}"
            -var "timeout_hours=${TIMEOUT_HOURS}"
            -var "fuzzers=${fuzzers}"
            -var "run_id=${RUN_ID}"
            -var "scfuzzbench_commit=${GITHUB_SHA}"
            -var "control_lock_table_name=${SCFUZZBENCH_LOCK_TABLE}"
            -var "control_lock_name=${SCFUZZBENCH_LOCK_NAME}"
          )

          if [[ -n "${FOUNDRY_VERSION}" ]]; then
            tf_args+=(-var "foundry_version=${FOUNDRY_VERSION}")
          fi
          if [[ -n "${FOUNDRY_GIT_REPO}" ]]; then
            tf_args+=(-var "foundry_git_repo=${FOUNDRY_GIT_REPO}")
          fi
          if [[ -n "${FOUNDRY_GIT_REF}" ]]; then
            tf_args+=(-var "foundry_git_ref=${FOUNDRY_GIT_REF}")
          fi
          if [[ -n "${ECHIDNA_VERSION}" ]]; then
            tf_args+=(-var "echidna_version=${ECHIDNA_VERSION}")
          fi
          if [[ -n "${MEDUSA_VERSION}" ]]; then
            tf_args+=(-var "medusa_version=${MEDUSA_VERSION}")
          fi
          if [[ -n "${BITWUZLA_VERSION}" ]]; then
            tf_args+=(-var "bitwuzla_version=${BITWUZLA_VERSION}")
          fi
          if [[ -n "${GIT_TOKEN_SSM_PARAMETER_NAME}" ]]; then
            tf_args+=(-var "git_token_ssm_parameter_name=${GIT_TOKEN_SSM_PARAMETER_NAME}")
          fi

          if [[ -n "${FUZZER_ENV_JSON}" || -n "${PROPERTIES_PATH}" ]]; then
            merged=$(python3 - <<'PY'
          import json
          import os

          data = {}
          raw = os.environ.get("FUZZER_ENV_JSON", "").strip()
          if raw:
              data.update(json.loads(raw))
          prop = os.environ.get("PROPERTIES_PATH", "").strip()
          if prop:
              data["SCFUZZBENCH_PROPERTIES_PATH"] = prop
          print(json.dumps(data))
          PY
            )
            tf_args+=(-var "fuzzer_env=${merged}")
          fi

          terraform -chdir=infrastructure apply -auto-approve "${tf_args[@]}"

      - name: Collect Terraform outputs
        id: tf_outputs
        run: |
          terraform -chdir=infrastructure output -json > run_metadata.json
          run_id=$(jq -r '.run_id.value' run_metadata.json)
          benchmark_uuid=$(jq -r '.benchmark_uuid.value' run_metadata.json)
          {
            echo "run_id=${run_id}"
            echo "benchmark_uuid=${benchmark_uuid}"
          } >> "${GITHUB_OUTPUT}"

      - name: Initialize queue state and enqueue shards
        id: init_queue
        run: |
          set -euo pipefail
          jq -c '.shards.value' run_metadata.json > shards.json
          python3 scripts/queue_init_run.py \
            --queue-url "$(jq -r '.queue_url.value' run_metadata.json)" \
            --run-state-table "$(jq -r '.run_state_table_name.value' run_metadata.json)" \
            --run-id "$(jq -r '.run_id.value' run_metadata.json)" \
            --benchmark-uuid "$(jq -r '.benchmark_uuid.value' run_metadata.json)" \
            --max-parallel-effective "$(jq -r '.max_parallel_effective.value' run_metadata.json)" \
            --shards-json shards.json

      - name: Mark lock handoff
        id: lock_handoff
        if: ${{ steps.init_queue.outcome == 'success' }}
        run: echo "handoff=true" >> "${GITHUB_OUTPUT}"

      - name: Release global lock on bootstrap failure
        if: ${{ failure() && steps.lock.outputs.lock_acquired == 'true' && steps.lock_handoff.outputs.handoff != 'true' }}
        env:
          RUN_ID: ${{ steps.shard_plan.outputs.run_id }}
        run: |
          set -euo pipefail
          key="$(jq -cn --arg lock_name "${SCFUZZBENCH_LOCK_NAME}" '{lock_name:{S:$lock_name}}')"
          vals="$(jq -cn --arg run_id "${RUN_ID}" '{":owner":{S:$run_id}}')"
          aws dynamodb delete-item \
            --table-name "${SCFUZZBENCH_LOCK_TABLE}" \
            --key "${key}" \
            --condition-expression "owner_run_id = :owner" \
            --expression-attribute-values "${vals}" >/dev/null || true

      - name: Upload run metadata
        uses: actions/upload-artifact@v4
        with:
          name: run-metadata
          path: run_metadata.json

      - name: Summary
        run: |
          {
            echo "Benchmark run started."
            echo ""
            echo "- Run ID: ${{ steps.tf_outputs.outputs.run_id }}"
            echo "- Benchmark UUID: ${{ steps.tf_outputs.outputs.benchmark_uuid }}"
            echo "- Requested shards: ${{ steps.shard_plan.outputs.requested_shards }}"
            echo "- Effective parallel workers: ${{ steps.shard_plan.outputs.effective_parallel }}"
          } >> "${GITHUB_STEP_SUMMARY}"
