name: Benchmark Run

on:
  workflow_dispatch:
    inputs:
      target_repo_url:
        description: "Target repository URL."
        required: true
      target_commit:
        description: "Target repository commit hash."
        required: true
      benchmark_type:
        description: "Benchmark type."
        required: true
        type: choice
        options:
          - property
          - optimization
        default: property
      instance_type:
        description: "EC2 instance type."
        required: true
        default: c6a.8xlarge
      instances_per_fuzzer:
        description: "Number of instances per fuzzer."
        required: true
        type: number
        default: 10
      timeout_hours:
        description: "Timeout per fuzzer run (hours)."
        required: true
        type: number
        default: 24
      fuzzers_json:
        description: "JSON list of fuzzer keys to run (optional)."
        required: false
        default: '["echidna","medusa","foundry"]'
      foundry_version:
        description: "Override Foundry version (optional)."
        required: false
        default: ""
      foundry_git_repo:
        description: "Optional Foundry git repo (build from source)."
        required: false
        default: ""
      foundry_git_ref:
        description: "Optional Foundry git ref (branch/tag/commit)."
        required: false
        default: ""
      echidna_version:
        description: "Override Echidna version (optional)."
        required: false
        default: ""
      medusa_version:
        description: "Override Medusa version (optional)."
        required: false
        default: ""
      bitwuzla_version:
        description: "Override Bitwuzla version (optional)."
        required: false
        default: ""
      git_token_ssm_parameter_name:
        description: "SSM parameter name for Git token (optional)."
        required: false
        default: ""
      properties_path:
        description: "Repo-relative properties path for benchmark mode switching (optional)."
        required: false
        default: ""
      fuzzer_env_json:
        description: "JSON map of extra fuzzer env vars (optional)."
        required: false
        default: ""
  workflow_call:
    inputs:
      target_repo_url:
        description: "Target repository URL."
        required: true
        type: string
      target_commit:
        description: "Target repository commit hash."
        required: true
        type: string
      benchmark_type:
        description: "Benchmark type."
        required: false
        type: string
        default: property
      instance_type:
        description: "EC2 instance type."
        required: false
        type: string
        default: c6a.8xlarge
      instances_per_fuzzer:
        description: "Number of instances per fuzzer."
        required: false
        type: number
        default: 10
      timeout_hours:
        description: "Timeout per fuzzer run (hours)."
        required: false
        type: number
        default: 24
      fuzzers_json:
        description: "JSON list of fuzzer keys to run (optional)."
        required: false
        type: string
        default: '["echidna","medusa","foundry"]'
      foundry_version:
        description: "Override Foundry version (optional)."
        required: false
        type: string
        default: ""
      foundry_git_repo:
        description: "Optional Foundry git repo (build from source)."
        required: false
        type: string
        default: ""
      foundry_git_ref:
        description: "Optional Foundry git ref (branch/tag/commit)."
        required: false
        type: string
        default: ""
      echidna_version:
        description: "Override Echidna version (optional)."
        required: false
        type: string
        default: ""
      medusa_version:
        description: "Override Medusa version (optional)."
        required: false
        type: string
        default: ""
      bitwuzla_version:
        description: "Override Bitwuzla version (optional)."
        required: false
        type: string
        default: ""
      git_token_ssm_parameter_name:
        description: "SSM parameter name for Git token (optional)."
        required: false
        type: string
        default: ""
      properties_path:
        description: "Repo-relative properties path for benchmark mode switching (optional)."
        required: false
        type: string
        default: ""
      fuzzer_env_json:
        description: "JSON map of extra fuzzer env vars (optional)."
        required: false
        type: string
        default: ""
    secrets:
      AWS_ACCESS_KEY_ID:
        required: true
      AWS_SECRET_ACCESS_KEY:
        required: true
      SCFUZZBENCH_BUCKET:
        required: true
      TF_BACKEND_CONFIG:
        required: true
      AWS_REGION:
        required: false
    outputs:
      run_id:
        description: "Run ID (Unix timestamp)."
        value: ${{ jobs.benchmark-run.outputs.run_id }}
      benchmark_uuid:
        description: "Benchmark UUID (derived from manifest)."
        value: ${{ jobs.benchmark-run.outputs.benchmark_uuid }}

permissions:
  contents: read

concurrency:
  group: benchmark-run-global-dispatch
  cancel-in-progress: false

jobs:
  benchmark-run:
    runs-on: ubuntu-latest
    outputs:
      run_id: ${{ steps.tf_outputs.outputs.run_id }}
      benchmark_uuid: ${{ steps.tf_outputs.outputs.benchmark_uuid }}
    env:
      AWS_REGION: ${{ secrets.AWS_REGION != '' && secrets.AWS_REGION || 'us-east-1' }}
      SCFUZZBENCH_BUCKET: ${{ secrets.SCFUZZBENCH_BUCKET }}
      SCFUZZBENCH_LOCK_TABLE: scfuzzbench-control-locks
      SCFUZZBENCH_LOCK_NAME: benchmark-global-lock
      SCFUZZBENCH_LOCK_LEASE_SECONDS: "7200"
      SCFUZZBENCH_LOCK_ACQUIRE_TIMEOUT_SECONDS: "0"
      SCFUZZBENCH_LOCK_ACQUIRE_MAX_BACKOFF_SECONDS: "120"
      SCFUZZBENCH_LOCK_RENEW_HEARTBEAT_SECONDS: "60"
      TF_APPLY_MAX_ATTEMPTS: "6"
      TF_APPLY_BASE_BACKOFF_SECONDS: "30"
      TF_APPLY_MAX_BACKOFF_SECONDS: "300"
    steps:
      - name: Checkout (tarball)
        timeout-minutes: 5
        env:
          REPO: ${{ github.repository }}
          SHA: ${{ github.sha }}
        run: |
          set -euo pipefail
          url="https://codeload.github.com/${REPO}/tar.gz/${SHA}"
          curl -fsSL "${url}" -o repo.tar.gz
          topdir="$(tar -tzf repo.tar.gz | sed -n '1p' | cut -d/ -f1)"
          tar -xzf repo.tar.gz
          shopt -s dotglob
          mv "${topdir}"/* .
          rm -rf "${topdir}" repo.tar.gz

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.5.7

      - name: Ensure AWS credentials are configured
        run: |
          if [ -z "${{ secrets.AWS_ACCESS_KEY_ID }}" ] || [ -z "${{ secrets.AWS_SECRET_ACCESS_KEY }}" ]; then
            echo "Set AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY secrets." >&2
            exit 1
          fi
          if [ -z "${AWS_REGION}" ]; then
            echo "Set AWS_REGION secret." >&2
            exit 1
          fi
          if [ -z "${SCFUZZBENCH_BUCKET}" ]; then
            echo "Set SCFUZZBENCH_BUCKET secret." >&2
            exit 1
          fi

      - name: Configure AWS credentials (keys)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Write backend config from secret
        env:
          TF_BACKEND_CONFIG: ${{ secrets.TF_BACKEND_CONFIG }}
        run: |
          set -euo pipefail
          if [ -n "${TF_BACKEND_CONFIG}" ]; then
            printf '%s' "${TF_BACKEND_CONFIG}" > infrastructure/backend.hcl
          fi

      - name: Ensure backend config exists
        run: |
          if [ ! -f infrastructure/backend.hcl ]; then
            echo "Missing infrastructure/backend.hcl. Create it or set TF_BACKEND_CONFIG secret." >&2
            exit 1
          fi

      - name: Terraform init (remote backend)
        run: make terraform-init-backend BACKEND_CONFIG=backend.hcl

      - name: Validate inputs
        env:
          TARGET_REPO_URL: ${{ inputs.target_repo_url }}
          TARGET_COMMIT: ${{ inputs.target_commit }}
          BENCHMARK_TYPE: ${{ inputs.benchmark_type }}
          INSTANCE_TYPE: ${{ inputs.instance_type }}
          INSTANCES_PER_FUZZER: ${{ inputs.instances_per_fuzzer }}
          TIMEOUT_HOURS: ${{ inputs.timeout_hours }}
          FUZZERS_JSON: ${{ inputs.fuzzers_json }}
          FOUNDRY_VERSION: ${{ inputs.foundry_version }}
          FOUNDRY_GIT_REPO: ${{ inputs.foundry_git_repo }}
          FOUNDRY_GIT_REF: ${{ inputs.foundry_git_ref }}
          ECHIDNA_VERSION: ${{ inputs.echidna_version }}
          MEDUSA_VERSION: ${{ inputs.medusa_version }}
          BITWUZLA_VERSION: ${{ inputs.bitwuzla_version }}
          GIT_TOKEN_SSM_PARAMETER_NAME: ${{ inputs.git_token_ssm_parameter_name }}
          PROPERTIES_PATH: ${{ inputs.properties_path }}
          FUZZER_ENV_JSON: ${{ inputs.fuzzer_env_json }}
        run: |
          set -euo pipefail

          fail() {
            echo "Invalid input: $1" >&2
            exit 1
          }

          is_single_line() {
            [[ "$1" != *$'\n'* && "$1" != *$'\r'* ]]
          }

          # These values are interpolated into Terraform args and later into user-data.
          # Keep them conservative to avoid shell-quoting surprises.
          has_forbidden_chars() {
            local s="$1"
            [[ "$s" == *\"* || "$s" == *"$"* || "$s" == *$'\x60'* || "$s" == *\\* ]]
          }

          require_safe() {
            local name="$1"
            local value="$2"
            if ! is_single_line "$value"; then
              fail "${name} must be a single line"
            fi
            if has_forbidden_chars "$value"; then
              fail "${name} contains a forbidden character (double quote, backslash, dollar sign, or backtick)"
            fi
          }

          require_safe "target_repo_url" "${TARGET_REPO_URL}"
          require_safe "target_commit" "${TARGET_COMMIT}"
          require_safe "benchmark_type" "${BENCHMARK_TYPE}"
          require_safe "instance_type" "${INSTANCE_TYPE}"

          if [[ -n "${FOUNDRY_VERSION}" ]]; then
            require_safe "foundry_version" "${FOUNDRY_VERSION}"
            if [[ ! "${FOUNDRY_VERSION}" =~ ^[A-Za-z0-9._+-]+$ ]]; then
              fail "foundry_version must not contain spaces"
            fi
          fi

          if [[ -n "${FOUNDRY_GIT_REPO}" ]]; then
            require_safe "foundry_git_repo" "${FOUNDRY_GIT_REPO}"
            if [[ ! "${FOUNDRY_GIT_REPO}" =~ ^https://github\.com/[A-Za-z0-9_.-]+/[A-Za-z0-9_.-]+(\.git)?/?$ ]]; then
              fail "foundry_git_repo must be https://github.com/<org>/<repo>"
            fi
          fi

          if [[ -n "${FOUNDRY_GIT_REF}" ]]; then
            require_safe "foundry_git_ref" "${FOUNDRY_GIT_REF}"
            if [[ ! "${FOUNDRY_GIT_REF}" =~ ^[A-Za-z0-9._/-]+$ ]]; then
              fail "foundry_git_ref must not contain spaces"
            fi
          fi

          if [[ -n "${ECHIDNA_VERSION}" ]]; then
            require_safe "echidna_version" "${ECHIDNA_VERSION}"
          fi
          if [[ -n "${MEDUSA_VERSION}" ]]; then
            require_safe "medusa_version" "${MEDUSA_VERSION}"
          fi
          if [[ -n "${BITWUZLA_VERSION}" ]]; then
            require_safe "bitwuzla_version" "${BITWUZLA_VERSION}"
          fi

          if [[ ! "${TARGET_REPO_URL}" =~ ^https://github\.com/[A-Za-z0-9_.-]+/[A-Za-z0-9_.-]+(\.git)?/?$ ]]; then
            fail "target_repo_url must be https://github.com/<org>/<repo>"
          fi

          if [[ ! "${TARGET_COMMIT}" =~ ^[A-Za-z0-9][A-Za-z0-9._/-]{0,199}$ ]]; then
            fail "target_commit must be a commit SHA, tag, or branch (no spaces)"
          fi

          case "${BENCHMARK_TYPE}" in
            property|optimization) ;;
            *) fail "benchmark_type must be property or optimization" ;;
          esac

          if [[ ! "${INSTANCE_TYPE}" =~ ^[a-z0-9]+\.[a-z0-9]+$ ]]; then
            fail "instance_type must look like c6a.4xlarge"
          fi

          if [[ ! "${INSTANCES_PER_FUZZER}" =~ ^[0-9]+$ ]] || (( INSTANCES_PER_FUZZER < 1 )) || (( INSTANCES_PER_FUZZER > 20 )); then
            fail "instances_per_fuzzer must be an integer in [1, 20]"
          fi

          if [[ ! "${TIMEOUT_HOURS}" =~ ^[0-9]+(\.[0-9]+)?$ ]]; then
            fail "timeout_hours must be a number"
          fi
          python3 - <<'PY'
          import os
          hours = float(os.environ["TIMEOUT_HOURS"])
          if hours < 0.25 or hours > 72:
              raise SystemExit("timeout_hours must be in [0.25, 72]")
          PY

          python3 - <<'PY'
          import json
          import os
          import re

          raw = os.environ.get("FUZZERS_JSON", "").strip()
          if not raw:
              raw = '["echidna","medusa","foundry"]'
          try:
              obj = json.loads(raw)
          except Exception as e:
              raise SystemExit(f"fuzzers_json must be valid JSON: {e}")
          if not isinstance(obj, list):
              raise SystemExit("fuzzers_json must be a JSON list")
          if len(obj) < 1:
              raise SystemExit("fuzzers_json must include at least one fuzzer key")
          if len(obj) > 20:
              raise SystemExit("fuzzers_json has too many entries (max 20)")
          key_re = re.compile(r"^[a-z0-9][a-z0-9-]{0,63}$")
          for v in obj:
              if not isinstance(v, str) or not key_re.match(v):
                  raise SystemExit(f"Invalid fuzzer key: {v!r}")
          PY

          if [[ -n "${GIT_TOKEN_SSM_PARAMETER_NAME}" ]]; then
            require_safe "git_token_ssm_parameter_name" "${GIT_TOKEN_SSM_PARAMETER_NAME}"
            if [[ ! "${GIT_TOKEN_SSM_PARAMETER_NAME}" =~ ^/scfuzzbench/[A-Za-z0-9_./-]+$ ]]; then
              fail "git_token_ssm_parameter_name must start with /scfuzzbench/"
            fi
          fi

          if [[ -n "${PROPERTIES_PATH}" ]]; then
            require_safe "properties_path" "${PROPERTIES_PATH}"
            if [[ "${PROPERTIES_PATH}" == /* || "${PROPERTIES_PATH}" == *".."* ]]; then
              fail "properties_path must be repo-relative and must not contain '..'"
            fi
            if [[ ! "${PROPERTIES_PATH}" =~ ^[A-Za-z0-9_./-]+$ ]]; then
              fail "properties_path must not contain spaces"
            fi
          fi

          if [[ -n "${FUZZER_ENV_JSON}" ]]; then
            python3 - <<'PY'
          import json
          import os
          import re
          raw = os.environ["FUZZER_ENV_JSON"]
          try:
              obj = json.loads(raw)
          except Exception as e:
              raise SystemExit(f"Invalid fuzzer_env_json: {e}")
          if not isinstance(obj, dict):
              raise SystemExit("fuzzer_env_json must be a JSON object")
          if len(obj) > 64:
              raise SystemExit("fuzzer_env_json has too many keys (max 64)")
          key_re = re.compile(r"^[A-Z][A-Z0-9_]{0,63}$")
          forbidden = re.compile(r'[\r\n"`$\\\\]')
          for k, v in obj.items():
              if not isinstance(k, str) or not key_re.match(k):
                  raise SystemExit(f"Invalid env key: {k}")
              if not isinstance(v, str):
                  raise SystemExit(f"Env value for {k} must be a string")
              if len(v) > 2000:
                  raise SystemExit(f"Env value for {k} too long (max 2000 chars)")
              if forbidden.search(v):
                  raise SystemExit(f"Env value for {k} contains a forbidden character")
          PY
          fi

      - name: Plan shards and discover effective parallelism
        id: shard_plan
        env:
          INSTANCE_TYPE: ${{ inputs.instance_type }}
          INSTANCES_PER_FUZZER: ${{ inputs.instances_per_fuzzer }}
          FUZZERS_JSON: ${{ inputs.fuzzers_json }}
        run: |
          set -euo pipefail
          run_id="$(date +%s)"
          fuzzers="${FUZZERS_JSON:-}"
          if [[ -z "${fuzzers}" ]]; then
            fuzzers='["echidna","medusa","foundry"]'
          fi
          fuzzer_count="$(python3 - <<'PY'
          import json
          import os
          obj = json.loads(os.environ["FUZZERS_JSON"] or '["echidna","medusa","foundry"]')
          print(len(obj))
          PY
          )"
          requested_shards="$((INSTANCES_PER_FUZZER * fuzzer_count))"

          instance_vcpus="$(aws ec2 describe-instance-types --instance-types "${INSTANCE_TYPE}" --query 'InstanceTypes[0].VCpuInfo.DefaultVCpus' --output text 2>/dev/null || true)"
          quota_vcpus="$(aws service-quotas get-service-quota --service-code ec2 --quota-code L-1216C47A --query 'Quota.Value' --output text 2>/dev/null || true)"
          effective_parallel="$(REQUESTED_SHARDS="${requested_shards}" INSTANCE_VCPUS="${instance_vcpus}" QUOTA_VCPUS="${quota_vcpus}" python3 - <<'PY'
          import math
          import os

          requested = int(os.environ["REQUESTED_SHARDS"])
          instance_vcpus = os.environ.get("INSTANCE_VCPUS", "").strip()
          quota_vcpus = os.environ.get("QUOTA_VCPUS", "").strip()

          effective = requested
          try:
              iv = int(float(instance_vcpus))
              qv = float(quota_vcpus)
              if iv > 0 and qv > 0:
                  slots = int(math.floor(qv / iv))
                  if slots < 1:
                      slots = 1
                  effective = min(requested, slots)
          except Exception:
              pass

          if effective < 1:
              effective = 1
          print(effective)
          PY
          )"

          {
            echo "run_id=${run_id}"
            echo "fuzzers_json=${fuzzers}"
            echo "requested_shards=${requested_shards}"
            echo "effective_parallel=${effective_parallel}"
            echo "instance_vcpus=${instance_vcpus}"
            echo "quota_vcpus=${quota_vcpus}"
          } >> "${GITHUB_OUTPUT}"

      - name: Ensure global lock table exists
        run: |
          set -euo pipefail
          python3 scripts/benchmark_lock.py ensure-table \
            --table-name "${SCFUZZBENCH_LOCK_TABLE}"

      - name: Acquire global run lock
        id: lock
        env:
          RUN_ID: ${{ steps.shard_plan.outputs.run_id }}
          LOCK_LEASE_SECONDS: ${{ env.SCFUZZBENCH_LOCK_LEASE_SECONDS }}
          LOCK_WAIT_TIMEOUT_SECONDS: ${{ env.SCFUZZBENCH_LOCK_ACQUIRE_TIMEOUT_SECONDS }}
          LOCK_MAX_BACKOFF_SECONDS: ${{ env.SCFUZZBENCH_LOCK_ACQUIRE_MAX_BACKOFF_SECONDS }}
        run: |
          set -euo pipefail
          python3 scripts/benchmark_lock.py acquire \
            --table-name "${SCFUZZBENCH_LOCK_TABLE}" \
            --lock-name "${SCFUZZBENCH_LOCK_NAME}" \
            --owner-run-id "${RUN_ID}" \
            --workflow-run-id "${GITHUB_RUN_ID}" \
            --lease-seconds "${LOCK_LEASE_SECONDS}" \
            --wait-timeout-seconds "${LOCK_WAIT_TIMEOUT_SECONDS}" \
            --max-backoff-seconds "${LOCK_MAX_BACKOFF_SECONDS}"

      - name: Terraform apply
        id: apply
        env:
          TARGET_REPO_URL: ${{ inputs.target_repo_url }}
          TARGET_COMMIT: ${{ inputs.target_commit }}
          BENCHMARK_TYPE: ${{ inputs.benchmark_type }}
          INSTANCE_TYPE: ${{ inputs.instance_type }}
          INSTANCES_PER_FUZZER: ${{ inputs.instances_per_fuzzer }}
          TIMEOUT_HOURS: ${{ inputs.timeout_hours }}
          FUZZERS_JSON: ${{ steps.shard_plan.outputs.fuzzers_json }}
          MAX_PARALLEL_EFFECTIVE: ${{ steps.shard_plan.outputs.effective_parallel }}
          RUN_ID: ${{ steps.shard_plan.outputs.run_id }}
          FOUNDRY_VERSION: ${{ inputs.foundry_version }}
          FOUNDRY_GIT_REPO: ${{ inputs.foundry_git_repo }}
          FOUNDRY_GIT_REF: ${{ inputs.foundry_git_ref }}
          ECHIDNA_VERSION: ${{ inputs.echidna_version }}
          MEDUSA_VERSION: ${{ inputs.medusa_version }}
          BITWUZLA_VERSION: ${{ inputs.bitwuzla_version }}
          GIT_TOKEN_SSM_PARAMETER_NAME: ${{ inputs.git_token_ssm_parameter_name }}
          FUZZER_ENV_JSON: ${{ inputs.fuzzer_env_json }}
          PROPERTIES_PATH: ${{ inputs.properties_path }}
          LOCK_LEASE_SECONDS: ${{ steps.lock.outputs.lock_lease_seconds || env.SCFUZZBENCH_LOCK_LEASE_SECONDS }}
          LOCK_HEARTBEAT_SECONDS: "120"
          TF_APPLY_MAX_ATTEMPTS: ${{ env.TF_APPLY_MAX_ATTEMPTS }}
          TF_APPLY_BASE_BACKOFF_SECONDS: ${{ env.TF_APPLY_BASE_BACKOFF_SECONDS }}
          TF_APPLY_MAX_BACKOFF_SECONDS: ${{ env.TF_APPLY_MAX_BACKOFF_SECONDS }}
          LOCK_RENEW_HEARTBEAT_SECONDS: ${{ env.SCFUZZBENCH_LOCK_RENEW_HEARTBEAT_SECONDS }}
        run: |
          set -euo pipefail
          fuzzers="${FUZZERS_JSON:-}"
          if [[ -z "${fuzzers}" ]]; then
            fuzzers='["echidna","medusa","foundry"]'
          fi
          if ! [[ "${MAX_PARALLEL_EFFECTIVE}" =~ ^[0-9]+$ ]] || (( MAX_PARALLEL_EFFECTIVE < 1 )); then
            echo "Invalid MAX_PARALLEL_EFFECTIVE: ${MAX_PARALLEL_EFFECTIVE}" >&2
            exit 1
          fi
          if ! [[ "${LOCK_LEASE_SECONDS}" =~ ^[0-9]+$ ]] || (( LOCK_LEASE_SECONDS < 300 )); then
            echo "Invalid LOCK_LEASE_SECONDS: ${LOCK_LEASE_SECONDS}" >&2
            exit 1
          fi
          if ! [[ "${LOCK_HEARTBEAT_SECONDS}" =~ ^[0-9]+$ ]] || (( LOCK_HEARTBEAT_SECONDS < 30 )); then
            echo "Invalid LOCK_HEARTBEAT_SECONDS: ${LOCK_HEARTBEAT_SECONDS}" >&2
            exit 1
          fi
          if ! [[ "${LOCK_RENEW_HEARTBEAT_SECONDS}" =~ ^[0-9]+$ ]] || (( LOCK_RENEW_HEARTBEAT_SECONDS < 10 )); then
            echo "Invalid LOCK_RENEW_HEARTBEAT_SECONDS: ${LOCK_RENEW_HEARTBEAT_SECONDS}" >&2
            exit 1
          fi
          if ! [[ "${TF_APPLY_MAX_ATTEMPTS}" =~ ^[0-9]+$ ]] || (( TF_APPLY_MAX_ATTEMPTS < 1 )); then
            echo "Invalid TF_APPLY_MAX_ATTEMPTS: ${TF_APPLY_MAX_ATTEMPTS}" >&2
            exit 1
          fi
          if ! [[ "${TF_APPLY_BASE_BACKOFF_SECONDS}" =~ ^[0-9]+$ ]] || (( TF_APPLY_BASE_BACKOFF_SECONDS < 1 )); then
            echo "Invalid TF_APPLY_BASE_BACKOFF_SECONDS: ${TF_APPLY_BASE_BACKOFF_SECONDS}" >&2
            exit 1
          fi
          if ! [[ "${TF_APPLY_MAX_BACKOFF_SECONDS}" =~ ^[0-9]+$ ]] || (( TF_APPLY_MAX_BACKOFF_SECONDS < TF_APPLY_BASE_BACKOFF_SECONDS )); then
            echo "Invalid TF_APPLY_MAX_BACKOFF_SECONDS: ${TF_APPLY_MAX_BACKOFF_SECONDS}" >&2
            exit 1
          fi

          tf_common_args=(
            -var "aws_region=${AWS_REGION}"
            -var "existing_bucket_name=${SCFUZZBENCH_BUCKET}"
            -var "target_repo_url=${TARGET_REPO_URL}"
            -var "target_commit=${TARGET_COMMIT}"
            -var "benchmark_type=${BENCHMARK_TYPE}"
            -var "instance_type=${INSTANCE_TYPE}"
            -var "instances_per_fuzzer=${INSTANCES_PER_FUZZER}"
            -var "timeout_hours=${TIMEOUT_HOURS}"
            -var "fuzzers=${fuzzers}"
            -var "run_id=${RUN_ID}"
            -var "scfuzzbench_commit=${GITHUB_SHA}"
            -var "control_lock_table_name=${SCFUZZBENCH_LOCK_TABLE}"
            -var "control_lock_name=${SCFUZZBENCH_LOCK_NAME}"
            -var "control_lock_lease_seconds=${LOCK_LEASE_SECONDS}"
            -var "control_lock_heartbeat_seconds=${LOCK_HEARTBEAT_SECONDS}"
          )

          if [[ -n "${FOUNDRY_VERSION}" ]]; then
            tf_common_args+=(-var "foundry_version=${FOUNDRY_VERSION}")
          fi
          if [[ -n "${FOUNDRY_GIT_REPO}" ]]; then
            tf_common_args+=(-var "foundry_git_repo=${FOUNDRY_GIT_REPO}")
          fi
          if [[ -n "${FOUNDRY_GIT_REF}" ]]; then
            tf_common_args+=(-var "foundry_git_ref=${FOUNDRY_GIT_REF}")
          fi
          if [[ -n "${ECHIDNA_VERSION}" ]]; then
            tf_common_args+=(-var "echidna_version=${ECHIDNA_VERSION}")
          fi
          if [[ -n "${MEDUSA_VERSION}" ]]; then
            tf_common_args+=(-var "medusa_version=${MEDUSA_VERSION}")
          fi
          if [[ -n "${BITWUZLA_VERSION}" ]]; then
            tf_common_args+=(-var "bitwuzla_version=${BITWUZLA_VERSION}")
          fi
          if [[ -n "${GIT_TOKEN_SSM_PARAMETER_NAME}" ]]; then
            tf_common_args+=(-var "git_token_ssm_parameter_name=${GIT_TOKEN_SSM_PARAMETER_NAME}")
          fi

          if [[ -n "${FUZZER_ENV_JSON}" || -n "${PROPERTIES_PATH}" ]]; then
            merged=$(python3 - <<'PY'
          import json
          import os

          data = {}
          raw = os.environ.get("FUZZER_ENV_JSON", "").strip()
          if raw:
              data.update(json.loads(raw))
          prop = os.environ.get("PROPERTIES_PATH", "").strip()
          if prop:
              data["SCFUZZBENCH_PROPERTIES_PATH"] = prop
          print(json.dumps(data))
          PY
            )
            tf_common_args+=(-var "fuzzer_env=${merged}")
          fi

          current_parallel="${MAX_PARALLEL_EFFECTIVE}"
          apply_attempt=1
          while true; do
            tf_args=("${tf_common_args[@]}" -var "max_parallel_instances=${current_parallel}")
            echo "Terraform apply attempt ${apply_attempt}/${TF_APPLY_MAX_ATTEMPTS} with max_parallel_instances=${current_parallel}"
            set +e
            (
              terraform -chdir=infrastructure apply -auto-approve "${tf_args[@]}" 2>&1 | tee terraform-apply.log
            ) &
            apply_pid=$!
            renew_failed=0
            while kill -0 "${apply_pid}" >/dev/null 2>&1; do
              sleep "${LOCK_RENEW_HEARTBEAT_SECONDS}" || true
              if ! kill -0 "${apply_pid}" >/dev/null 2>&1; then
                break
              fi
              if ! python3 scripts/benchmark_lock.py renew \
                --table-name "${SCFUZZBENCH_LOCK_TABLE}" \
                --lock-name "${SCFUZZBENCH_LOCK_NAME}" \
                --owner-run-id "${RUN_ID}" \
                --lease-seconds "${LOCK_LEASE_SECONDS}"; then
                renew_failed=1
                kill "${apply_pid}" >/dev/null 2>&1 || true
                break
              fi
            done
            wait "${apply_pid}"
            rc=$?
            set -e
            if (( renew_failed != 0 )); then
              echo "Failed to renew global lock during terraform apply; aborting bootstrap." >&2
              exit 1
            fi

            if (( rc == 0 )); then
              {
                echo "applied_parallel=${current_parallel}"
                echo "apply_attempts=${apply_attempt}"
              } >> "${GITHUB_OUTPUT}"
              break
            fi

            if (( apply_attempt >= TF_APPLY_MAX_ATTEMPTS )); then
              echo "Terraform apply failed after ${apply_attempt} attempt(s)." >&2
              exit "${rc}"
            fi

            if ! grep -Eiq "(InsufficientInstanceCapacity|VcpuLimitExceeded|RequestLimitExceeded|ServiceUnavailable|Unavailable|InternalError|InsufficientFreeAddressesInSubnet|capacity)" terraform-apply.log; then
              echo "Terraform apply failed with a non-retryable error." >&2
              exit "${rc}"
            fi

            next_parallel="${current_parallel}"
            if (( current_parallel > 1 )); then
              next_parallel=$((current_parallel - 1))
            fi

            exponent=$((apply_attempt - 1))
            raw_delay=$((TF_APPLY_BASE_BACKOFF_SECONDS * (2 ** exponent)))
            if (( raw_delay > TF_APPLY_MAX_BACKOFF_SECONDS )); then
              raw_delay=${TF_APPLY_MAX_BACKOFF_SECONDS}
            fi
            jitter=$((RANDOM % (TF_APPLY_BASE_BACKOFF_SECONDS + 1)))
            delay=$((raw_delay + jitter))
            if (( delay > TF_APPLY_MAX_BACKOFF_SECONDS )); then
              delay=${TF_APPLY_MAX_BACKOFF_SECONDS}
            fi

            echo "Capacity/transient apply failure detected. Retrying in ${delay}s with max_parallel_instances=${next_parallel}."
            current_parallel="${next_parallel}"
            apply_attempt=$((apply_attempt + 1))
            sleep "${delay}"
          done

      - name: Collect Terraform outputs
        id: tf_outputs
        run: |
          terraform -chdir=infrastructure output -json > run_metadata.json
          run_id=$(jq -r '.run_id.value' run_metadata.json)
          benchmark_uuid=$(jq -r '.benchmark_uuid.value' run_metadata.json)
          {
            echo "run_id=${run_id}"
            echo "benchmark_uuid=${benchmark_uuid}"
          } >> "${GITHUB_OUTPUT}"

      - name: Initialize queue state and enqueue shards
        id: init_queue
        run: |
          set -euo pipefail
          jq -c '.shards.value' run_metadata.json > shards.json
          python3 scripts/queue_init_run.py \
            --queue-url "$(jq -r '.queue_url.value' run_metadata.json)" \
            --run-state-table "$(jq -r '.run_state_table_name.value' run_metadata.json)" \
            --run-id "$(jq -r '.run_id.value' run_metadata.json)" \
            --benchmark-uuid "$(jq -r '.benchmark_uuid.value' run_metadata.json)" \
            --max-parallel-effective "$(jq -r '.max_parallel_effective.value' run_metadata.json)" \
            --shards-json shards.json \
            --summary-path queue-init-summary.json

      - name: Mark lock handoff
        id: lock_handoff
        if: ${{ steps.init_queue.outcome == 'success' }}
        run: echo "handoff=true" >> "${GITHUB_OUTPUT}"

      - name: Assess lock release safety on bootstrap failure
        id: lock_release_guard
        if: ${{ always() && steps.lock.outputs.lock_acquired == 'true' && steps.lock_handoff.outputs.handoff != 'true' }}
        run: |
          set -euo pipefail
          python3 scripts/benchmark_lock.py assess-bootstrap-release-safety \
            --queue-init-summary queue-init-summary.json \
            --run-metadata run_metadata.json

      - name: Keep lock after bootstrap failure when active run evidence exists
        if: ${{ failure() && steps.lock.outputs.lock_acquired == 'true' && steps.lock_handoff.outputs.handoff != 'true' && steps.lock_release_guard.outputs.safe_to_release != 'true' }}
        run: |
          {
            echo "Bootstrap failed after lock acquire."
            echo "Keeping global lock to avoid overlap with potentially active queue workers."
            echo "Reason: ${{ steps.lock_release_guard.outputs.reason }}"
          } >> "${GITHUB_STEP_SUMMARY}"

      - name: Release global lock on bootstrap failure
        if: ${{ failure() && steps.lock.outputs.lock_acquired == 'true' && steps.lock_handoff.outputs.handoff != 'true' && steps.lock_release_guard.outputs.safe_to_release == 'true' }}
        env:
          RUN_ID: ${{ steps.shard_plan.outputs.run_id }}
        run: |
          set -euo pipefail
          python3 scripts/benchmark_lock.py release \
            --table-name "${SCFUZZBENCH_LOCK_TABLE}" \
            --lock-name "${SCFUZZBENCH_LOCK_NAME}" \
            --owner-run-id "${RUN_ID}"

      - name: Upload run metadata
        uses: actions/upload-artifact@v4
        with:
          name: run-metadata
          path: run_metadata.json

      - name: Summary
        run: |
          applied_parallel="${{ steps.apply.outputs.applied_parallel }}"
          if [[ -z "${applied_parallel}" ]]; then
            applied_parallel="${{ steps.shard_plan.outputs.effective_parallel }}"
          fi
          {
            echo "Benchmark run started."
            echo ""
            echo "- Run ID: ${{ steps.tf_outputs.outputs.run_id }}"
            echo "- Benchmark UUID: ${{ steps.tf_outputs.outputs.benchmark_uuid }}"
            echo "- Requested shards: ${{ steps.shard_plan.outputs.requested_shards }}"
            echo "- Effective parallel workers (applied): ${applied_parallel}"
            echo "- Terraform apply attempts: ${{ steps.apply.outputs.apply_attempts }}"
            echo "- Global lock acquisition attempts: ${{ steps.lock.outputs.lock_attempts }}"
          } >> "${GITHUB_STEP_SUMMARY}"
